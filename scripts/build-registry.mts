import path from "node:path";
import { rimraf } from "rimraf";
import { promises as fs } from "node:fs";
import { exec } from "node:child_process";
import type {
	RegistryItem,
	RegistryItemFile,
	RegistryJson,
} from "./../src/types/registry";

const REGISTRY_JSON_PATH = path.join(
	process.cwd(),
	"public",
	"r",
	"registry.json",
);

/**
 * Function to build the merged registry.json file.
 * It searches for all registry-item.json files in the registry directory,
 * removes the $schema property, and merges them into the base registry.json items array.
 */
async function buildRegistryFile() {
	// Ensure the directory exists
	const registryDir = path.dirname(REGISTRY_JSON_PATH);
	await fs.mkdir(registryDir, { recursive: true });

	const registryData: RegistryJson = {
		$schema: "https://ui.shadcn.com/schema/registry.json",
		name: "craftui",
		homepage: "https://craft-ui.vercel.app",
		items: [],
	};

	const registryFolderPath = path.join(process.cwd(), "src", "registry");
	const newItems = await getRegistryItemsFromFolder(registryFolderPath);

	registryData.items = [
		{
			name: "index",
			type: "registry:style",
			dependencies: [
				"tw-animate-css",
				"class-variance-authority",
				"lucide-react",
			],
			registryDependencies: ["utils"],
			cssVars: {},
			files: [],
		},
		...newItems,
	];

	await fs.writeFile(
		REGISTRY_JSON_PATH,
		JSON.stringify(registryData, null, 2),
	);
}

/**
 * Recursively search for registry-item.json files in a given directory.
 * @param dir - Directory to search in.
 * @returns An array of registry item objects.
 */
async function getRegistryItemsFromFolder(registryDirPath: string) {
	const items: RegistryItem[] = [];
	const entries = await fs.readdir(registryDirPath, { withFileTypes: true });

	for (const entry of entries) {
		const fullPath = path.join(registryDirPath, entry.name);

		if (entry.isDirectory()) {
			const subItems = await getRegistryItemsFromFolder(fullPath);
			items.push(...subItems);
		} else if (entry.name === "registry-item.json") {
			const content = await fs.readFile(fullPath, "utf-8");
			const itemData = JSON.parse(content);

			if (itemData.$schema) {
				delete itemData.$schema;
			}

			items.push(itemData);
		}
	}

	return items;
}

/**
 * Replace registry paths with component paths.
 * @param inputStr - The input string to process.
 * @returns The processed string with registry paths replaced.
 */
function replaceRegistryPathsFromImport(inputStr: string): string {
	return inputStr.replace(/(['"])([\s\S]*?)\1/g, (match, quote, content) => {
		if (content.startsWith("@/registry/")) {
			const rest = content.slice("@/registry/".length);

			if (rest.startsWith("lib/") || rest.startsWith("hooks/")) {
				return `${quote}@/${rest}${quote}`;
			}

			return `${quote}@/components/craftui/${rest}${quote}`;
		} else if (content.startsWith("@craftui/ui/")) {
			const rest = content.slice("@craftui/ui/".length);
			return `${quote}@/${rest}${quote}`;
		}

		return match;
	});
}

/**
 * Function to build the registry index file.
 * This function reads the registry.json items and builds a dynamic index file.
 */
async function buildRegistryIndex() {
	const registryJsonContent = await fs.readFile(REGISTRY_JSON_PATH, "utf-8");
	const registryItems = JSON.parse(registryJsonContent);

	let index = "// @ts-nocheck\n";
	index += "// This file is autogenerated by scripts/build-registry.mts.\n";
	index += "// Do not edit this file directly.\n\n";
	index += "import React from 'react';\n\n";
	index += "export type RegistryType = typeof Registry;\n\n";
	index += "export const Registry: Record<string, any> = {\n";

	// remove duplicates: only keep the last item with a given name
	const uniqueItemsMap = new Map<string, (typeof registryItems.items)[0]>();

	// use the base items from registry.json merged file
	for (const item of registryItems.items) {
		if (uniqueItemsMap.has(item.name)) {
			console.warn(`Duplicate item name detected: ${item.name}`);
			process.exit(0);
		} else {
			uniqueItemsMap.set(item.name, item);
		}
	}

	for (const item of uniqueItemsMap.values()) {
		// skip items without files
		if (!item.files) continue;

		console.log("Processing item:", item.name);

		// define the component path from the first file if exists
		const componentPath = item.files[0]?.path
			? `@/${item.files[0].path.replace(/^src\//, "")}`
			: "";

		// read files and add content preserving newlines
		const filesWithContent = await Promise.all(
			item.files.map(async (file: RegistryItemFile) => {
				const filePath = typeof file === "string" ? file : file.path;
				const resolvedFilePath = path.resolve(filePath);

				try {
					// read the file content
					const content = await fs.readFile(
						resolvedFilePath,
						"utf-8",
					);
					const processedContent =
						replaceRegistryPathsFromImport(content).trim();

					return {
						path: filePath,
						type: file.type || "unknown",
						target: file.target,
						content: processedContent,
					};
				} catch (error) {
					console.error(`Error reading file ${filePath}:`, error);
					return {
						path: filePath,
						type: file.type || "unknown",
						target: file.target || "",
						content: "",
					};
				}
			}),
		);

		index += `
          "${item.name}": {
            name: ${JSON.stringify(item.name)},
            description: ${JSON.stringify(item.description ?? "")},
            type: "${item.type}",
            dependencies: ${JSON.stringify(item.dependencies)},
            devDependencies: ${JSON.stringify(item.devDependencies)},
            registryDependencies: ${JSON.stringify(item.registryDependencies)},
            files: ${JSON.stringify(filesWithContent, null, 2)},
            keywords: ${JSON.stringify(item.meta?.keywords ?? [])},
            command: '@craftui/${item.name}',
            component: ${
				componentPath
					? `(() => {
							const LazyComp = React.lazy(async () => {
								const mod = await import("${componentPath}");
								let Comp = mod.default;

								if (!Comp) {
									const exportName =
									Object.keys(mod).find((key) => {
										const value = mod[key];
										return typeof value === "function" || typeof value === "object";
									}) || "default";

									Comp = mod[exportName];
								}

								if (mod.animations) {
									(LazyComp as any).animations = mod.animations;
								}

								return { default: Comp };
							});

						    LazyComp.demoProps = ${JSON.stringify(item?.meta?.demoProps ?? {})};
							return LazyComp;
						})()`
					: "null"
			},
          },`;
	}

	index += `}`;

	// Ensure __registry__ directory exists
	const registryIndexDir = path.join(process.cwd(), "__registry__");
	await fs.mkdir(registryIndexDir, { recursive: true });

	// Remove the previous registry index file and write the new one.
	const registryIndexPath = path.join(registryIndexDir, "index.tsx");
	rimraf.sync(registryIndexPath);
	await fs.writeFile(registryIndexPath, index);
}

/**
 * Function to build the registry.
 * It clears the previous registry directory, builds the registry files,
 * and replaces specific path strings in the generated files.
 */
async function buildRegistry() {
	// ensure 'public/r' exists
	await fs.mkdir("public/r", { recursive: true });

	// remove everything except registry.json
	const entries = await fs.readdir("public/r");
	await Promise.all(
		entries.map(async (entry) => {
			if (entry === "registry.json") return;
			const entryPath = path.join("public/r", entry);
			await fs.rm(entryPath, { recursive: true, force: true });
		}),
	);

	// build the registry using the shadcn build command
	await new Promise((resolve, reject) => {
		const process = exec(
			`bunx shadcn@latest build public/r/registry.json --output ./public/r/`,
			(error, stdout, stderr) => {
				if (error) {
					console.error(`Error executing shadcn build: ${error}`);
					console.error(`stderr: ${stderr}`);
					reject(error);
					return;
				}
				console.log(`shadcn build output: ${stdout}`);
				resolve(undefined);
			},
		);

		// Fallback timeout to prevent hanging
		setTimeout(() => {
			process.kill();
			reject(
				new Error("shadcn build command timed out after 30 seconds"),
			);
		}, 30000);
	});

	// replace `@/registry/craftui/` with `@/components/craftui/` in all files
	const files = await fs.readdir(path.join(process.cwd(), "public/r"));

	await Promise.all(
		files.map(async (file) => {
			if (file === "registry.json") return; // Skip the main registry file

			const filePath = path.join(process.cwd(), "public/r", file);
			const content = await fs.readFile(filePath, "utf-8");

			try {
				const registryItem = JSON.parse(content);

				// Replace `@/registry` in file contents
				registryItem.files = registryItem.files?.map(
					(file: RegistryItemFile) => {
						if (
							file.content?.includes("@/registry") ||
							file.content?.includes("@workspace/ui/")
						) {
							file.content = replaceRegistryPathsFromImport(
								file.content,
							);
						}
						return file;
					},
				);

				// Write the updated file back to disk
				await fs.writeFile(
					filePath,
					JSON.stringify(registryItem, null, 2),
				);
			} catch (error) {
				console.error(`Error processing file ${file}:`, error);
			}
		}),
	);
}

// Execute the build process in the following order:
// 1. Build the merged registry.json file with new items from registry-item.json files.
// 2. Build the registry index.
// 3. Build the registry.
async function main() {
	try {
		console.log("1. Building merged registry file...");
		await buildRegistryFile();

		console.log("2. Building registry/__index__.tsx...");
		await buildRegistryIndex();

		console.log("3. Building registry...");
		await buildRegistry();

		console.log("Registry build completed successfully!");

		// Exit cleanly after success
		process.exit(0);
	} catch (error) {
		console.error("Build failed:", error);
		process.exit(1);
	}
}

// Run the main function
main();
